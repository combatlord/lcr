小小调度器任务函数的写法主要注意的，主要有三点：

1） 任务函数内部变量，建议都用静态局部变量来定义。
2） 任务函数内不能用switch语句。
3） 任务函数内，不能用return语句。 因为return已经被赋予任务延时的特定意义。（这是返回型任务函数版本的一个强制要求）

这三点，并不会明显造成写程序的不方便。
－－－－－－－－－－－－－－－－－－－－－－－－－－－
从裸奔到使用OS操作系统或调度系统的代价主要有：

硬件资源代价（对RAM和ROM的消耗），学习代价（学会其原理，并掌握其用法），移植代价（往不同cpu上移植的工作量），效率代价（使用调度系统后带来的额外cpu负担），商业代价（版权费用），稳定性代价（是否引入潜在不稳定因素，或者增大bug跟踪调试工作量）。

从这几方面来讲，应用小小调度器的代价，都是非常小的。
1） 硬件资源代价： 这个不用再说了，前面的优化版本已经说明问题。
2） 学习代价： 小小调度器总共只有十多行代码，如果我们做一个简单的解释说明，理解起来其实是很快的。我相信学习时间比其他调度系统要短。
3） 移植代价： 几乎没有什么移植工作量，对于各种cpu,几乎是通吃。
4） 效率代价： 我们一直在努力优化，相信调度效率已经不低了。比如任务切换时间，应该是可以做到uS级别，甚至亚uS级别。
5） 商业代价： 小小本调度器为免费使用，无需支付任何费用。
6） 稳定性代价：小小调度器本质上仅仅是几个宏而已，未涉及任何对内部寄存器或堆栈的操作，避免了引入不稳定风险因素，所有操作都在可预见，可把控的前提下进行。


__LINE__ 改为 __LINE__+((__LINE__%256)==0) 这个有重要意义的。只要任务内的WaitX所获行号不等于0，就达到效果。

因为400楼优化的思想是： switch 本来有个默认的default判断, 我想让 case 0 变为默认值， 也就是 让0 投入 default的怀抱。

既然 0 是任务的开始， （由于_lc是static静态的，初值自动是0， 然后在函数最后_lc=0,也是让任务下次被调用时，可以从头开始）： 那么其他任何WaitX获取的行都必须避开0这个值.   （至于257 和 513 重复，那个不管哈，自己加回车解决）

这样修改的另一个好处是： WaitX造成 重复case的概率也比以往的版本更低： 因为以往的版本都固定有case 0: 不管任务函数内部代码行数多还是少，一旦某个WaitX行落在256行的整数倍时，必然会造成重复case.


而400楼版本， 会自动在WaitX行号时避开0值， 至于避开后，如果再跟自己的另一个WaitX再读相撞，那这个概率要低很多的，

而且: 必须是一个任务函数内部的行数必须超过256行，才会发生这种257与513再次相撞的可能。如果任务函数内部代码少于256行，则不可能相撞。 内部代码行大于256行的任务函数实际上应该是很少的。


有一个可能相撞的情况： 256行和257行， 256行WaitX,自动取为257行，但257行恰好也是一个WaitX，它又不自动取为258，所以它们不幸地相撞了， 也就是连续两行都是WaitX,这种可能是有的。
这个很容易解决，加回车，或者不要连续两行都写WaitX.
